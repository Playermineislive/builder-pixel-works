{"version":3,"file":"node-build.mjs","sources":["../../server/routes/demo.ts","../../server/routes/auth.ts","../../server/routes/pairing.ts","../../server/index.ts","../../server/node-build.ts"],"sourcesContent":["import { RequestHandler } from \"express\";\nimport { DemoResponse } from \"@shared/api\";\n\nexport const handleDemo: RequestHandler = (req, res) => {\n  const response: DemoResponse = {\n    message: \"Hello from Express server\",\n  };\n  res.status(200).json(response);\n};\n","import { RequestHandler } from \"express\";\nimport bcrypt from \"bcryptjs\";\nimport jwt from \"jsonwebtoken\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { AuthRequest, AuthResponse, User } from \"@shared/api\";\n\n// In-memory storage for demo (in production, use a real database)\nconst users: Map<string, User & { passwordHash: string }> = new Map();\nconst usersByEmail: Map<string, User & { passwordHash: string }> = new Map();\n\nconst JWT_SECRET = process.env.JWT_SECRET || \"secure-chat-secret-key-change-in-production\";\n\n// Helper function to generate JWT token\nconst generateToken = (userId: string): string => {\n  return jwt.sign({ userId }, JWT_SECRET, { expiresIn: \"7d\" });\n};\n\n// Helper function to verify JWT token\nexport const verifyToken = (token: string): { userId: string } | null => {\n  try {\n    return jwt.verify(token, JWT_SECRET) as { userId: string };\n  } catch {\n    return null;\n  }\n};\n\n// Helper function to get user by ID\nexport const getUserById = (id: string): User | null => {\n  const user = users.get(id);\n  if (!user) return null;\n  \n  return {\n    id: user.id,\n    email: user.email,\n    createdAt: user.createdAt,\n  };\n};\n\nexport const handleSignup: RequestHandler = async (req, res) => {\n  try {\n    const { email, password }: AuthRequest = req.body;\n\n    // Validate input\n    if (!email || !password) {\n      const response: AuthResponse = {\n        success: false,\n        message: \"Email and password are required\",\n      };\n      return res.status(400).json(response);\n    }\n\n    // Check if user already exists\n    if (usersByEmail.has(email)) {\n      const response: AuthResponse = {\n        success: false,\n        message: \"User already exists with this email\",\n      };\n      return res.status(409).json(response);\n    }\n\n    // Hash password\n    const passwordHash = await bcrypt.hash(password, 12);\n\n    // Create user\n    const user: User & { passwordHash: string } = {\n      id: uuidv4(),\n      email,\n      passwordHash,\n      createdAt: new Date().toISOString(),\n    };\n\n    // Store user\n    users.set(user.id, user);\n    usersByEmail.set(email, user);\n\n    // Generate token\n    const token = generateToken(user.id);\n\n    const response: AuthResponse = {\n      success: true,\n      user: {\n        id: user.id,\n        email: user.email,\n        createdAt: user.createdAt,\n      },\n      token,\n    };\n\n    res.status(201).json(response);\n  } catch (error) {\n    console.error(\"Signup error:\", error);\n    const response: AuthResponse = {\n      success: false,\n      message: \"Internal server error\",\n    };\n    res.status(500).json(response);\n  }\n};\n\nexport const handleLogin: RequestHandler = async (req, res) => {\n  try {\n    const { email, password }: AuthRequest = req.body;\n\n    // Validate input\n    if (!email || !password) {\n      const response: AuthResponse = {\n        success: false,\n        message: \"Email and password are required\",\n      };\n      return res.status(400).json(response);\n    }\n\n    // Find user\n    const user = usersByEmail.get(email);\n    if (!user) {\n      const response: AuthResponse = {\n        success: false,\n        message: \"Invalid email or password\",\n      };\n      return res.status(401).json(response);\n    }\n\n    // Verify password\n    const isValidPassword = await bcrypt.compare(password, user.passwordHash);\n    if (!isValidPassword) {\n      const response: AuthResponse = {\n        success: false,\n        message: \"Invalid email or password\",\n      };\n      return res.status(401).json(response);\n    }\n\n    // Generate token\n    const token = generateToken(user.id);\n\n    const response: AuthResponse = {\n      success: true,\n      user: {\n        id: user.id,\n        email: user.email,\n        createdAt: user.createdAt,\n      },\n      token,\n    };\n\n    res.json(response);\n  } catch (error) {\n    console.error(\"Login error:\", error);\n    const response: AuthResponse = {\n      success: false,\n      message: \"Internal server error\",\n    };\n    res.status(500).json(response);\n  }\n};\n\nexport const handleVerifyToken: RequestHandler = (req, res) => {\n  try {\n    const authHeader = req.headers.authorization;\n    if (!authHeader || !authHeader.startsWith(\"Bearer \")) {\n      return res.status(401).json({ success: false, message: \"No token provided\" });\n    }\n\n    const token = authHeader.substring(7);\n    const decoded = verifyToken(token);\n    \n    if (!decoded) {\n      return res.status(401).json({ success: false, message: \"Invalid token\" });\n    }\n\n    const user = getUserById(decoded.userId);\n    if (!user) {\n      return res.status(401).json({ success: false, message: \"User not found\" });\n    }\n\n    const response: AuthResponse = {\n      success: true,\n      user,\n    };\n\n    res.json(response);\n  } catch (error) {\n    console.error(\"Token verification error:\", error);\n    res.status(500).json({ success: false, message: \"Internal server error\" });\n  }\n};\n","import { RequestHandler } from \"express\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { \n  PairingCode, \n  GenerateCodeResponse, \n  ConnectCodeRequest, \n  ConnectCodeResponse,\n  Connection,\n  ConnectionStatus\n} from \"@shared/api\";\nimport { verifyToken, getUserById } from \"./auth\";\n\n// In-memory storage for demo (in production, use a real database)\nconst pairingCodes: Map<string, PairingCode> = new Map();\nconst connections: Map<string, Connection> = new Map();\nconst userConnections: Map<string, string> = new Map(); // userId -> connectionId\n\n// Helper function to generate a unique 6-digit code\nconst generateUniqueCode = (): string => {\n  let code: string;\n  do {\n    code = Math.random().toString(36).substring(2, 8).toUpperCase();\n  } while (pairingCodes.has(code));\n  return code;\n};\n\n// Helper function to clean expired codes\nconst cleanExpiredCodes = () => {\n  const now = new Date();\n  for (const [code, pairingCode] of pairingCodes.entries()) {\n    if (new Date(pairingCode.expiresAt) <= now) {\n      pairingCodes.delete(code);\n    }\n  }\n};\n\n// Middleware to authenticate requests\nconst authenticateUser = (req: any, res: any, next: any) => {\n  const authHeader = req.headers.authorization;\n  if (!authHeader || !authHeader.startsWith(\"Bearer \")) {\n    return res.status(401).json({ success: false, message: \"No token provided\" });\n  }\n\n  const token = authHeader.substring(7);\n  const decoded = verifyToken(token);\n  \n  if (!decoded) {\n    return res.status(401).json({ success: false, message: \"Invalid token\" });\n  }\n\n  const user = getUserById(decoded.userId);\n  if (!user) {\n    return res.status(401).json({ success: false, message: \"User not found\" });\n  }\n\n  req.user = user;\n  next();\n};\n\nexport const handleGenerateCode: RequestHandler = (req: any, res) => {\n  try {\n    // Clean expired codes first\n    cleanExpiredCodes();\n\n    const userId = req.user.id;\n\n    // Clean up any stale connections for this user first\n    const existingConnectionId = userConnections.get(userId);\n    if (existingConnectionId) {\n      const existingConnection = connections.get(existingConnectionId);\n      if (existingConnection) {\n        // Remove stale connection\n        userConnections.delete(existingConnection.userId1);\n        userConnections.delete(existingConnection.userId2);\n        connections.delete(existingConnectionId);\n        console.log(`Cleaned up stale connection ${existingConnectionId} for user ${userId}`);\n      }\n    }\n\n    // Generate unique code\n    const code = generateUniqueCode();\n    const expiresAt = new Date(Date.now() + 5 * 60 * 1000).toISOString(); // 5 minutes\n\n    const pairingCode: PairingCode = {\n      code,\n      userId,\n      expiresAt,\n      isUsed: false,\n    };\n\n    pairingCodes.set(code, pairingCode);\n\n    const response: GenerateCodeResponse = {\n      success: true,\n      code,\n      expiresAt,\n    };\n\n    res.json(response);\n  } catch (error) {\n    console.error(\"Generate code error:\", error);\n    const response: GenerateCodeResponse = {\n      success: false,\n      message: \"Internal server error\",\n    };\n    res.status(500).json(response);\n  }\n};\n\nexport const handleConnectCode: RequestHandler = (req: any, res) => {\n  try {\n    // Clean expired codes first\n    cleanExpiredCodes();\n\n    const userId = req.user.id;\n    const { code }: ConnectCodeRequest = req.body;\n\n    if (!code) {\n      const response: ConnectCodeResponse = {\n        success: false,\n        message: \"Code is required\",\n      };\n      return res.status(400).json(response);\n    }\n\n    // Clean up any stale connections for this user first\n    const existingConnectionId = userConnections.get(userId);\n    if (existingConnectionId) {\n      const existingConnection = connections.get(existingConnectionId);\n      if (existingConnection) {\n        // Remove stale connection\n        userConnections.delete(existingConnection.userId1);\n        userConnections.delete(existingConnection.userId2);\n        connections.delete(existingConnectionId);\n        console.log(`Cleaned up stale connection ${existingConnectionId} for user ${userId}`);\n      }\n    }\n\n    // Find the pairing code\n    const pairingCode = pairingCodes.get(code.toUpperCase());\n    if (!pairingCode) {\n      const response: ConnectCodeResponse = {\n        success: false,\n        message: \"Invalid or expired code\",\n      };\n      return res.status(404).json(response);\n    }\n\n    // Check if code is expired\n    if (new Date(pairingCode.expiresAt) <= new Date()) {\n      pairingCodes.delete(code.toUpperCase());\n      const response: ConnectCodeResponse = {\n        success: false,\n        message: \"Code has expired\",\n      };\n      return res.status(410).json(response);\n    }\n\n    // Check if code is already used\n    if (pairingCode.isUsed) {\n      const response: ConnectCodeResponse = {\n        success: false,\n        message: \"Code has already been used\",\n      };\n      return res.status(410).json(response);\n    }\n\n    // Check if user is trying to connect to themselves\n    if (pairingCode.userId === userId) {\n      const response: ConnectCodeResponse = {\n        success: false,\n        message: \"You cannot connect to yourself\",\n      };\n      return res.status(400).json(response);\n    }\n\n    // Get partner user\n    const partner = getUserById(pairingCode.userId);\n    if (!partner) {\n      const response: ConnectCodeResponse = {\n        success: false,\n        message: \"Partner user not found\",\n      };\n      return res.status(404).json(response);\n    }\n\n    // Create connection\n    const connectionId = uuidv4();\n    const connection: Connection = {\n      id: connectionId,\n      userId1: pairingCode.userId,\n      userId2: userId,\n      createdAt: new Date().toISOString(),\n      isActive: true,\n    };\n\n    // Store connection\n    connections.set(connectionId, connection);\n    userConnections.set(pairingCode.userId, connectionId);\n    userConnections.set(userId, connectionId);\n\n    // Mark code as used and remove it\n    pairingCode.isUsed = true;\n    pairingCodes.delete(code.toUpperCase());\n\n    const response: ConnectCodeResponse = {\n      success: true,\n      partnerId: partner.id,\n      partnerEmail: partner.email,\n    };\n\n    res.json(response);\n  } catch (error) {\n    console.error(\"Connect code error:\", error);\n    const response: ConnectCodeResponse = {\n      success: false,\n      message: \"Internal server error\",\n    };\n    res.status(500).json(response);\n  }\n};\n\nexport const handleGetConnectionStatus: RequestHandler = (req: any, res) => {\n  try {\n    const userId = req.user.id;\n    const connectionId = userConnections.get(userId);\n\n    if (!connectionId) {\n      const response: ConnectionStatus = {\n        isConnected: false,\n      };\n      return res.json(response);\n    }\n\n    const connection = connections.get(connectionId);\n    if (!connection || !connection.isActive) {\n      userConnections.delete(userId);\n      const response: ConnectionStatus = {\n        isConnected: false,\n      };\n      return res.json(response);\n    }\n\n    // Get partner info\n    const partnerId = connection.userId1 === userId ? connection.userId2 : connection.userId1;\n    const partner = getUserById(partnerId);\n\n    const response: ConnectionStatus = {\n      isConnected: true,\n      partnerId,\n      partnerEmail: partner?.email,\n      connectionId,\n    };\n\n    res.json(response);\n  } catch (error) {\n    console.error(\"Get connection status error:\", error);\n    res.status(500).json({ success: false, message: \"Internal server error\" });\n  }\n};\n\nexport const handleDisconnect: RequestHandler = (req: any, res) => {\n  try {\n    const userId = req.user.id;\n    const connectionId = userConnections.get(userId);\n\n    if (!connectionId) {\n      return res.json({ success: true, message: \"Already disconnected\" });\n    }\n\n    const connection = connections.get(connectionId);\n    if (connection) {\n      // Mark connection as inactive\n      connection.isActive = false;\n      \n      // Remove both users from active connections\n      userConnections.delete(connection.userId1);\n      userConnections.delete(connection.userId2);\n    }\n\n    res.json({ success: true, message: \"Disconnected successfully\" });\n  } catch (error) {\n    console.error(\"Disconnect error:\", error);\n    res.status(500).json({ success: false, message: \"Internal server error\" });\n  }\n};\n\n// Export middleware for use in other routes\nexport { authenticateUser };\n\n// Export helper functions for WebSocket usage\nexport const getUserConnection = (userId: string): Connection | null => {\n  const connectionId = userConnections.get(userId);\n  if (!connectionId) return null;\n  \n  const connection = connections.get(connectionId);\n  return connection?.isActive ? connection : null;\n};\n\nexport const getPartnerIdForUser = (userId: string): string | null => {\n  const connection = getUserConnection(userId);\n  if (!connection) return null;\n  \n  return connection.userId1 === userId ? connection.userId2 : connection.userId1;\n};\n","import \"dotenv/config\";\nimport express from \"express\";\nimport cors from \"cors\";\nimport { createServer } from \"http\";\nimport { Server } from \"socket.io\";\nimport { handleDemo } from \"./routes/demo\";\nimport { \n  handleSignup, \n  handleLogin, \n  handleVerifyToken, \n  verifyToken, \n  getUserById \n} from \"./routes/auth\";\nimport { \n  handleGenerateCode, \n  handleConnectCode, \n  handleGetConnectionStatus, \n  handleDisconnect, \n  authenticateUser, \n  getPartnerIdForUser \n} from \"./routes/pairing\";\nimport { WebSocketMessage } from \"@shared/api\";\n\nexport function createAppServer() {\n  const app = express();\n  const httpServer = createServer(app);\n  \n  // Setup Socket.IO with CORS\n  const io = new Server(httpServer, {\n    cors: {\n      origin: \"*\", // In production, specify your domain\n      methods: [\"GET\", \"POST\"]\n    }\n  });\n\n  // Middleware\n  app.use(cors());\n  app.use(express.json());\n  app.use(express.urlencoded({ extended: true }));\n\n  // Test routes\n  app.get(\"/api/ping\", (_req, res) => {\n    const ping = process.env.PING_MESSAGE ?? \"ping\";\n    res.json({ message: ping });\n  });\n\n  app.get(\"/api/demo\", handleDemo);\n\n  // Authentication routes\n  app.post(\"/api/auth/signup\", handleSignup);\n  app.post(\"/api/auth/login\", handleLogin);\n  app.get(\"/api/auth/verify\", handleVerifyToken);\n\n  // Pairing routes (require authentication)\n  app.post(\"/api/pairing/generate-code\", authenticateUser, handleGenerateCode);\n  app.post(\"/api/pairing/connect-code\", authenticateUser, handleConnectCode);\n  app.get(\"/api/pairing/status\", authenticateUser, handleGetConnectionStatus);\n  app.post(\"/api/pairing/disconnect\", authenticateUser, handleDisconnect);\n\n  // WebSocket authentication middleware\n  io.use((socket, next) => {\n    const token = socket.handshake.auth.token;\n    if (!token) {\n      return next(new Error(\"Authentication error\"));\n    }\n\n    const decoded = verifyToken(token);\n    if (!decoded) {\n      return next(new Error(\"Authentication error\"));\n    }\n\n    const user = getUserById(decoded.userId);\n    if (!user) {\n      return next(new Error(\"User not found\"));\n    }\n\n    socket.userId = user.id;\n    socket.userEmail = user.email;\n    next();\n  });\n\n  // Store active socket connections and public keys\n  const userSockets = new Map<string, string>(); // userId -> socketId\n  const userPublicKeys = new Map<string, string>(); // userId -> publicKey\n\n  // WebSocket connection handling\n  io.on(\"connection\", (socket: any) => {\n    console.log(`User connected: ${socket.userEmail} (${socket.userId})`);\n    \n    // Store user's socket connection\n    userSockets.set(socket.userId, socket.id);\n\n    // Notify partner about connection\n    const partnerId = getPartnerIdForUser(socket.userId);\n    if (partnerId) {\n      const partnerSocketId = userSockets.get(partnerId);\n      if (partnerSocketId) {\n        const message: WebSocketMessage = {\n          type: \"user_connected\",\n          data: { userId: socket.userId, email: socket.userEmail },\n          timestamp: new Date().toISOString(),\n        };\n        io.to(partnerSocketId).emit(\"message\", message);\n\n        // Exchange public keys if both users have them\n        const partnerPublicKey = userPublicKeys.get(partnerId);\n        const userPublicKey = userPublicKeys.get(socket.userId);\n        \n        if (partnerPublicKey) {\n          socket.emit(\"key_exchange\", { \n            publicKey: partnerPublicKey, \n            userId: partnerId \n          });\n        }\n        \n        if (userPublicKey && partnerSocketId) {\n          io.to(partnerSocketId).emit(\"key_exchange\", { \n            publicKey: userPublicKey, \n            userId: socket.userId \n          });\n        }\n      }\n    }\n\n    // Handle key exchange\n    socket.on(\"key_exchange\", (data: { publicKey: string }) => {\n      console.log(`Received public key from ${socket.userEmail}`);\n      \n      // Store the public key\n      userPublicKeys.set(socket.userId, data.publicKey);\n      \n      // Send to partner if connected\n      const partnerId = getPartnerIdForUser(socket.userId);\n      if (partnerId) {\n        const partnerSocketId = userSockets.get(partnerId);\n        if (partnerSocketId) {\n          io.to(partnerSocketId).emit(\"key_exchange\", {\n            publicKey: data.publicKey,\n            userId: socket.userId\n          });\n          console.log(`Forwarded public key to partner ${partnerId}`);\n        }\n      }\n    });\n\n    // Handle incoming messages (can be encrypted or plain text)\n    socket.on(\"send_message\", (data: { content: string | object; type: string }) => {\n      try {\n        const partnerId = getPartnerIdForUser(socket.userId);\n        if (!partnerId) {\n          socket.emit(\"error\", { message: \"No active connection\" });\n          return;\n        }\n\n        const partnerSocketId = userSockets.get(partnerId);\n        if (!partnerSocketId) {\n          socket.emit(\"error\", { message: \"Partner not online\" });\n          return;\n        }\n\n        const message: WebSocketMessage = {\n          type: \"message\",\n          data: {\n            senderId: socket.userId,\n            content: data.content, // Can be encrypted object or plain string\n            type: data.type || \"text\",\n            timestamp: new Date().toISOString(),\n          },\n          timestamp: new Date().toISOString(),\n        };\n\n        // Send to partner\n        io.to(partnerSocketId).emit(\"message\", message);\n        \n        // Send confirmation back to sender\n        socket.emit(\"message_sent\", { success: true });\n      } catch (error) {\n        console.error(\"Message sending error:\", error);\n        socket.emit(\"error\", { message: \"Failed to send message\" });\n      }\n    });\n\n    // Handle typing indicators\n    socket.on(\"typing\", (data: { isTyping: boolean }) => {\n      try {\n        const partnerId = getPartnerIdForUser(socket.userId);\n        if (!partnerId) return;\n\n        const partnerSocketId = userSockets.get(partnerId);\n        if (!partnerSocketId) return;\n\n        const message: WebSocketMessage = {\n          type: \"typing\",\n          data: {\n            userId: socket.userId,\n            isTyping: data.isTyping,\n          },\n          timestamp: new Date().toISOString(),\n        };\n\n        io.to(partnerSocketId).emit(\"message\", message);\n      } catch (error) {\n        console.error(\"Typing indicator error:\", error);\n      }\n    });\n\n    // Handle disconnection\n    socket.on(\"disconnect\", () => {\n      console.log(`User disconnected: ${socket.userEmail} (${socket.userId})`);\n      \n      // Remove from active connections\n      userSockets.delete(socket.userId);\n      userPublicKeys.delete(socket.userId);\n\n      // Notify partner about disconnection\n      const partnerId = getPartnerIdForUser(socket.userId);\n      if (partnerId) {\n        const partnerSocketId = userSockets.get(partnerId);\n        if (partnerSocketId) {\n          const message: WebSocketMessage = {\n            type: \"user_disconnected\",\n            data: { userId: socket.userId, email: socket.userEmail },\n            timestamp: new Date().toISOString(),\n          };\n          io.to(partnerSocketId).emit(\"message\", message);\n        }\n      }\n    });\n  });\n\n  return httpServer;\n}\n\n// For development with Vite\nexport function createServer() {\n  const app = express();\n\n  // Middleware\n  app.use(cors());\n  app.use(express.json());\n  app.use(express.urlencoded({ extended: true }));\n\n  // Test routes\n  app.get(\"/api/ping\", (_req, res) => {\n    const ping = process.env.PING_MESSAGE ?? \"ping\";\n    res.json({ message: ping });\n  });\n\n  app.get(\"/api/demo\", handleDemo);\n\n  // Authentication routes\n  app.post(\"/api/auth/signup\", handleSignup);\n  app.post(\"/api/auth/login\", handleLogin);\n  app.get(\"/api/auth/verify\", handleVerifyToken);\n\n  // Pairing routes (require authentication)\n  app.post(\"/api/pairing/generate-code\", authenticateUser, handleGenerateCode);\n  app.post(\"/api/pairing/connect-code\", authenticateUser, handleConnectCode);\n  app.get(\"/api/pairing/status\", authenticateUser, handleGetConnectionStatus);\n  app.post(\"/api/pairing/disconnect\", authenticateUser, handleDisconnect);\n\n  return app;\n}\n","import path from \"path\";\nimport { createServer } from \"./index\";\nimport * as express from \"express\";\n\nconst app = createServer();\nconst port = process.env.PORT || 3000;\n\n// In production, serve the built SPA files\nconst __dirname = import.meta.dirname;\nconst distPath = path.join(__dirname, \"../spa\");\n\n// Serve static files\napp.use(express.static(distPath));\n\n// Handle React Router - serve index.html for all non-API routes\napp.get(\"*\", (req, res) => {\n  // Don't serve index.html for API routes\n  if (req.path.startsWith(\"/api/\") || req.path.startsWith(\"/health\")) {\n    return res.status(404).json({ error: \"API endpoint not found\" });\n  }\n\n  res.sendFile(path.join(distPath, \"index.html\"));\n});\n\napp.listen(port, () => {\n  console.log(`ðŸš€ Fusion Starter server running on port ${port}`);\n  console.log(`ðŸ“± Frontend: http://localhost:${port}`);\n  console.log(`ðŸ”§ API: http://localhost:${port}/api`);\n});\n\n// Graceful shutdown\nprocess.on(\"SIGTERM\", () => {\n  console.log(\"ðŸ›‘ Received SIGTERM, shutting down gracefully\");\n  process.exit(0);\n});\n\nprocess.on(\"SIGINT\", () => {\n  console.log(\"ðŸ›‘ Received SIGINT, shutting down gracefully\");\n  process.exit(0);\n});\n"],"names":["response","uuidv4","app","express"],"mappings":"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"}